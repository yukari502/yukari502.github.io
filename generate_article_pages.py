#!/usr/bin/env python3
"""
Generate static HTML pages for each article.
This enables better SEO and direct article linking while maintaining the SPA experience for the main site.
"""

import os
import json
import re
import urllib.parse
import glob
from pathlib import Path

def read_markdown_file(file_path):
    """Read markdown file and strip frontmatter"""
    with open(file_path, 'r', encoding='utf-8') as f:
        content = f.read()
    
    # Strip frontmatter if present
    content = re.sub(r'^---\s*\n[\s\S]*?\n---\s*\n', '', content)
    return content

def generate_article_html(article, template_content, base_url, output_dir):
    """Generate HTML file for a single article"""
    
    # Read the markdown file
    file_path = urllib.parse.unquote(article['path'])
    
    if not os.path.exists(file_path):
        print(f"Warning: File not found: {file_path}")
        return None
    
    markdown_content = read_markdown_file(file_path)
    
    # Use slug from article info (generated by generate_articles_json.py)
    # If not present (backward compatibility), fallback to simple slugify
    if 'slug' in article:
        slug = article['slug']
    else:
        # Fallback slugify if not in json
        slug = article['filename'].replace('.md', '').lower()
        slug = re.sub(r'[^\w\s-]', '', slug)
        slug = re.sub(r'[-\s]+', '-', slug).strip('-')
        
    if 'category' in article:
        # We need to slugify category too if we don't have it stored
        # But generate_articles_json now handles it.
        # Let's just rely on the URL structure we decided: posts/category_slug/file_slug.html
        # We can extract category slug from the URL if we want, or just re-slugify category
        pass

    # Actually, we can just parse the article['url'] if available
    if 'url' in article:
        # url is like /posts/category/slug.html
        # Remove leading /
        rel_url = article['url'].lstrip('/')
        output_file = os.path.join(output_dir, '..', rel_url) # output_dir is 'posts', so we need to go up?
        # No, generate_all_articles sets output_dir = 'posts'
        # If rel_url is 'posts/cat/slug.html', then os.path.join('posts', rel_url) would be posts/posts/cat/slug.html
        # We should just use the relative path from root.
        # Let's adjust: output_dir is where we want to write.
        # If we want to write to 'posts/cat/slug.html', and we run from root.
        output_file = rel_url
    else:
        # Fallback logic
        category_slug = article.get('category', 'uncategorized').lower().replace(' ', '-')
        output_file = os.path.join('posts', category_slug, f"{slug}.html")

    # Ensure directory exists
    os.makedirs(os.path.dirname(output_file), exist_ok=True)
    
    # Prepare template variables
    # Use the pre-generated URL or construct it
    output_url = article.get('url', f"/posts/{slug}.html") # This might be wrong in fallback but we expect url to be there
    
    replacements = {
        '{TITLE}': article['title'],
        '{DESCRIPTION}': article.get('description', '')[:160],  # Limit for meta description
        '{KEYWORDS}': f"{article.get('category', '')}, {article['title']}",
        '{URL}': f"{base_url}{output_url}",
        '{DATE}': article.get('date', ''),
        '{CATEGORY}': article.get('category', 'Uncategorized'),
        '{CONTENT}': markdown_content  # We'll process this with marked.js on client side
    }
    
    # Replace placeholders in template
    html_content = template_content
    for key, value in replacements.items():
        html_content = html_content.replace(key, str(value))
    
    # Write the HTML file
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write(html_content)
    
    print(f"Generated: {output_file}")
    
    # Return the URL path for sitemap
    return output_url

def generate_all_articles():
    """Generate HTML pages for all articles"""
    
    articles_json = 'articles.json'
    template_file = 'article-template.html'
    output_dir = 'posts'
    base_url = 'https://yukari502.github.io'
    
    # Create output directory
    os.makedirs(output_dir, exist_ok=True)
    
    # Read template
    if not os.path.exists(template_file):
        print(f"Error: Template file not found: {template_file}")
        return []
    
    with open(template_file, 'r', encoding='utf-8') as f:
        template_content = f.read()
    
    # Read articles
    if not os.path.exists(articles_json):
        print(f"Error: Articles JSON not found: {articles_json}")
        return []
    
    with open(articles_json, 'r', encoding='utf-8') as f:
        articles = json.load(f)
    
    # Generate HTML for each article
    generated_urls = []
    for article in articles:
        url_path = generate_article_html(article, template_content, base_url, output_dir)
        if url_path:
            generated_urls.append({
                'url': url_path,
                'lastmod': article.get('date', ''),
                'title': article.get('title', '')
            })
    
    print(f"\nâœ… Generated {len(generated_urls)} article pages in '{output_dir}/' directory")
    
    return generated_urls

if __name__ == "__main__":
    generate_all_articles()
